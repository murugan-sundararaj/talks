Why golang?
Why for Anomaly Manager REST service (AMS)

Murugan Sundararaj
Flipkart
@murugan-sundararaj

* What is Go?

- Go is an open source project developed by a team at Google and many contributors from the open source community.
- Go is distributed under a BSD-style license.
- Go is a statically typed, garbage-collected, natively compiled programming language.
- Plenty of tools available to improve the quality and efficiency of Go code.
    - gofmt for example formats your code. A nice side effect is all Go code will carry uniform formatting.

* Concurrency
- Go lets you write concurrent program without worrying about the number of threads or thread pool

- Go uses green threads (lightweight threads) called goroutines.

- Create thousands of them, if not tens.

- Use channels to communicate between goroutines.

* No more GC tuning

- As said earlier, Go is a garbage collected language. Programmers can focus just on solving the biz problem and still write leakage free code.
- Go compiler team is working aggressively on reducing the GC latency.
- Today Go GC latencies are below 10 ms. Improved further in Go1.6. Even more in Go1.7 (currently in beta).

- provide a link to GC video. 10ms under what scenario?

- Plus points

    - Learning curve is simple.

    - Profiling, testing, debugging are not afterthoughts.

    - Built in support for Concurrent programming.

    - Simple Build system.

    - Simple Dependency management.
- Go in production
    - Some popular datastores built using Go

        - etcd - Distributed reliable key-value store for the most critical data of a distributed system
        - Cockroachdb (beta) - Distributed, scale-out, sql database
        - Influxdb
    - Internally used by PaaS.
- But why use it in AMS

    - One of the most compelling reasons for using Go is having the concept of concurrent asynchronous programming as part of the language.
    - The argument always came up that you can do asynchronous programming in Java...but it isn’t pretty. My argument was always that “We can keep doing it in Java,” ….but just because you can do something with a technology doesn’t mean its the best way to do it.

Workflow:
Each price change event POSTed to AMS might contain one or more listings.
Scatter:
Loop through the event and extract the listing block one after the other.
The moment a listing block is extracted, somebody can process the same while the next listing is extracted.
Essentially, each listing is processed as they are unpacked from the event.
Each process in turn would involve more than one network call
     To get the past price changes of the listing
     To get the corresponding sales data
     To get x,y,z in the future
Gather:
Collect the results from various pipelines.
Apply the detection algorithm.
Some algorithms need not wait for all pipelines to finish.
Send the response.

Three key nfr (there could be more) needed for effective REST service

    - Non-blocking i/o calls
    - Timeouts on external calls
    - Limit the rate of input — rate limiting

Non-blocking i/o

- Easy to implement scatter and gather paradigm.

    - Processing each listing in the price change event concurrently

    - Each listing process involves more than one network call

        - Get the past price

        - Get the sum of units sold and other relevant data between (how getting the sales unit in real time help in detecting the outlier?)

    - Implementing timeouts in Go is easy and elegant

        - https://gobyexample.com/timeouts

    - https://gobyexample.com/rate-limiting

Rate limiting is an important mechanism for controlling resource utilization and maintaining quality of service. Go elegantly supports rate limiting with goroutines, channels, and tickers.

Still not convinced….
Hear from the co-creator of Go, Rob Pike https://www.youtube.com/watch?v=FTl0tl9BGdc#t=196.999387
